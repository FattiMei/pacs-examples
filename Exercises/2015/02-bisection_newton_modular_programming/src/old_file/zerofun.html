/*!
  \file zerofun.hpp
  \brief Algorithms to find the root of a non-linear equation
  
  Given a continuous function f(x) on a real interval [a, b],
  such that f(a)f(b) < 0, these methods evaluate its zero in (a, b)
  
  \author Daniele A. Di Pietro
  \author Luca Formaggia
  \author Tiziano Passerini
  \date 25-10-2006
*/

#ifndef ZEROFUN_HPP
#define ZEROFUN_HPP 1

#include "rootfinding.hpp"

bool converged(real const & increment, real const & residual, real const & tol, checkT const & check);

/*!
  \name Algorithms
  
  Some parameters are used in each algorithm.

  <dl compact>
    <dt><b> Input Parameters: </b></dt>
    <dd>
      <small><em> These are defined \i const as they wont be modified inside the procedures. </em></small>

      <table border="0" cellspacing="2" cellpadding="0">
        <tr>
	  <td valign="top"></td>
	  <td valign="top"><em>tol</em>&nbsp;</td>
	  <td>tolerance for the approximate solution</td>
	</tr>
	<tr>
	  <td valign="top"></td>
	  <td valign="top"><em>maxit</em>&nbsp;</td>
	  <td>maximum number of iterations</td>
	</tr>
	<tr>
	  <td valign="top"></td>
	  <td valign="top"><em>check</em>&nbsp;</td>
	  <td>type of convergence check (INCREMENT or RESIDUAL)</td>
	</tr>
      </table>
  </dl>

  <dl compact>
    <dt><b>Input/Output Parameters:</b></dt>
    <dd>
      <small><em>This parameters is overwritten inside the procedure,
      and you don't have to bother on how to initialize it.</em></small>

      <table border="0" cellspacing="2" cellpadding="0">
        <tr>
	  <td valign="top"></td>
	  <td valign="top"><em>nit</em>&nbsp;</td>
	  <td>actual number of iterations performed by the algorithm</td>
        </tr>
      </table>
  </dl>

*/

/*@{*/
//! Bisection method
/*!
  \param a left boundary
  \param b right boundary
  \param f pointer to function f(x)
*/
real bisection(real const & a, real const & b, fctptr const f, 
	       real const & tol, int const & maxit,
	       checkT const & check, int & nit);

real newton(real const & xp, fctptr const f, fctptr const df,
	    real const & tol, int const & maxit,
	    checkT const & check, int & nit);

real robust(real const & a, real const & b,
	    real const & xp, fctptr const f, fctptr const df,
	    real const & tol, real const & cfratio, 
	    int const & maxit, checkT const & check, int & nit);

/*@}*/

#endif
