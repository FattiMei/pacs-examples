\section*{Solution}

\begin{enumerate}

\item Main aspects of the solution for question 1:

\begin{itemize}

\item Both declarations and definitions of templated classes and methods mus be in a header files, for this reason we collected all the class declarations and implementations in one single header file. Other code organizations are possible as explained in the lectures.

\item In a class template derived names are 
resolved only when a template class is instantiated 
so methods and attributes in the derived classes {\tt Bisection}, {\tt Newton}, and {\tt Robust} that are inherited from the base class {\tt IterativeMethod}
must be prepended by {\tt this->} so that the compiler
can understand they are dependent identifiers and only try to resolve them when the templated classes are instantiated.

\item For a similar reason the typedefs in the base
class need to be fully qualified when used in the derived classes.

\item Using the {\tt STL} class template {\tt numeric\_limits}.

\end{itemize}

Main file:

\lstinputlisting{ex8_sol1/bn.cpp}

Header defining all the class templates:
\lstinputlisting{ex8_sol1/iterativeMethod.hpp}

\item Main aspects of the solution for question 2:

\begin{itemize}
\item Notice that, unless specifying {\tt -std=c++11}, a space is required when two {\tt >} 
symbols appear consecutively in a template parameter list.
\end{itemize}

Main file:

\lstinputlisting{ex8_sol2/bn.cpp}

Header defining all the class templates:
\lstinputlisting{ex8_sol2/iterativeMethod.hpp}

\end{enumerate}




