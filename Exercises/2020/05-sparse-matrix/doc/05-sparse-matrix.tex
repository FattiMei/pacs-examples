\documentclass[10pt]{beamer}
\usetheme{default}
\setbeamercovered{invisible}
\setbeamertemplate{navigation symbols}{}
\setbeamertemplate{footline}{
    \flushright{\hfill \insertframenumber{}/\inserttotalframenumber}
}

\usepackage{listings}

% User-defined colors.
\definecolor{DarkGreen}{rgb}{0, .5, 0}
\definecolor{DarkBlue}{rgb}{0, 0, .5}
\definecolor{DarkRed}{rgb}{.5, 0, 0}
\definecolor{LightGray}{rgb}{.95, .95, .95}
\definecolor{White}{rgb}{1.0,1.0,1.0}
\definecolor{darkblue}{rgb}{0,0,0.9}
\definecolor{darkred}{rgb}{0.8,0,0}
\definecolor{darkgreen}{rgb}{0.0,0.85,0}

% Settings for listing class.
\lstset{
  language=C++,                        % The default language
  basicstyle=\small\ttfamily,          % The basic style
  backgroundcolor=\color{White},       % Set listing background
  keywordstyle=\color{DarkBlue}\bfseries, % Set keyword style
  commentstyle=\color{DarkGreen}\itshape, % Set comment style
  stringstyle=\color{DarkRed}, % Set string constant style
  extendedchars=true % Allow extended characters
  breaklines=true,
  basewidth={0.5em,0.4em},
  fontadjust=true,
  linewidth=\textwidth,
  breakatwhitespace=true,
  showstringspaces=false,
  lineskip=0ex, %  frame=single
}

\begin{document}
    \title{A sparse matrix class based on STL containers}
    \author{Pasquale Claudio Africa}
    \date{17/04/2020}

\begin{frame}[plain, noframenumbering]
    \maketitle
\end{frame}


\begin{frame}{What is a sparse matrix?}
\begin{itemize}
\item A (square) sparse matrix is a matrix whose number of non-zero elements $N_{nz}$ is $O(N)$, 
$N$ being the size of the matrix. \\[3mm]
\item The average number $m$ of non-zero elements per row (or column)
is constant w.r.t. the matrix size. \\[3mm]
\item If the majority of matrix entries is $0$, {\it i.e.} if $m \ll N$ it is convenient to store only the non-zero elements.\\[3mm]
\item The matrix-vector product (which is the basic ingredient of Krylov solvers) is $O(N)$ rather than $O(N^{2})$.\\[3mm]
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Some Examples of Sparse Matrix Formats}
Some (slightly revisited) classical data structures for sparse matrices

\begin{equation*}
A = 
\begin{bmatrix}
4  & -1 & 0  & 0\\
-1 &  4 & -1 & 0\\
0  & -1 &  4 & -1\\
0  &  0 &  -1& 4
\end{bmatrix}
\end{equation*}

\begin{itemize}
\item [COO] (coordinates) or AIJ: \tiny
\begin{lstlisting}
std::vector<double> A{4, -1, -1, ...};
std::vector<int>    I{0,  0,  1, ...};
std::vector<int>    J{0,  1,  0, ...};
\end{lstlisting} \normalsize
\item [triplet]: \tiny
\begin{lstlisting}
std::vector<std::tuple<int, int, double>> 
{{0, 0, 4}, {0, 1, -1}, {1, 0, -1}, ...};
\end{lstlisting} \normalsize
\item [CSR] (Compressed Sparse Row) or CRS (Compr. Row Storage) or Yale:\tiny
\begin{lstlisting}
std::vector<double> val{4, -1, -1, 4, -1, -1, 4, -1, -1, 4};
std::vector<int>    col_ind{0, 1, 0, 1, 2, 1, 2, 3, 2, 3};
std::vector<int>    row_ptr{0, 2, 5, 8, 10}; // One element per row.
\end{lstlisting} 
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Typical operations with sparse matrices} 
\begin{itemize}
\item Insertion: \\
\lstinline|A[i][j] = x;|
\item Deletion: \\
\lstinline|A[i].erase (j);|
\item Random access: \\
\lstinline|x = A[i][j]; A[i][j] += y;|
\item Sequential traversing:
\small\begin{lstlisting}
for (row : A)
  {
    for (column : row)
  	  std::cout << column << " ";
    std::cout << std::endl;
  }
\end{lstlisting}\normalsize
\item Matrix-vector multiplication:\\
\lstinline|std::vector<double> y = A * x;|
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Why not to inherit from STL containers}
\begin{itemize}
\item The C++ standard leaves a lot of freedom for implementation of containers.
\item STL containers have non-virtual destructors.
\item \href{http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines\#Rc-dtor-virtual}{C.35: A base class destructor should be either public and virtual, or protected and non-virtual.}
\small\begin{lstlisting}
class D : public B {
public :
 MyComplexType member;
 ~D { member.clear(); ... }
}

class B {
 public :
 ~B { do_something(); }; // Non-virtual.
}

B* var = new D;
delete var; // Calls var::~B() but not var::~D()!
\end{lstlisting}\normalsize
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Exercise: Sparse Matrix class}
\begin{itemize}
\item Implement a C++ class to represent a sparse matrix based on STL containers.
\item Simplify random access, allocation, entry increment, sequential traversing.
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Exercise: Sparse Matrix class}
Implement the following methods:
\begin{lstlisting}[basicstyle=\footnotesize]
/// Convert row-oriented sparse matrix to CRS format.
void csr(std::vector<double> &a,
         std::vector<int> &col_ind,
         std::vector<int> &row_ptr);

/// Update the entries of a sparse matrix in CSR format.
void csr_update(std::vector<double> &a,
                const std::vector<int> &col_ind,
                const std::vector<int> &row_ptr);

/// Stream output operator.
std::ostream & operator<< (std::ostream &stream,
                           sparse_matrix &M);

/// Sparse matrix increment.
/// Automatically allocates additional entries.
void sparse_matrix::operator+= (sparse_matrix &other);

/// Compute matrix-vector product.
friend std::vector<double>
operator*(sparse_matrix &M, const std::vector<double> &x);
\end{lstlisting}
\end{frame}
  
\end{document}